"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AttachmentsService = void 0;
const testit_api_client_1 = require("testit-api-client");
const common_1 = require("../../common");
const base_service_1 = require("../base.service");
const buffer_1 = require("buffer");
const apiKey = testit_api_client_1.AttachmentsApiApiKeys["Bearer or PrivateToken"];
class AttachmentsService extends base_service_1.BaseService {
    constructor(config) {
        super(config);
        this.config = config;
        this._client = new testit_api_client_1.AttachmentsApi(config.url);
        this._client.setApiKey(apiKey, `PrivateToken ${config.privateToken}`);
    }
    uploadTextAttachment(content, filename) {
        return __awaiter(this, void 0, void 0, function* () {
            const request = {
                value: buffer_1.Buffer.from(content, "utf-8"),
                options: { filename: filename !== null && filename !== void 0 ? filename : common_1.Utils.generateFileName() },
            };
            return yield this._client.apiV2AttachmentsPost(request).then(({ body }) => [{ id: body.id }]);
        });
    }
    uploadAttachments(paths) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield Promise.all(paths.map((path) => {
                const extension = common_1.Utils.getExtName(path);
                const headers = {};
                if (extension.search("txt") >= 0) {
                    headers["Content-Type"] = "text/plain";
                }
                if (extension.search(/jp[e?]g/) >= 0) {
                    headers["Content-Type"] = "image";
                }
                return this._client
                    .apiV2AttachmentsPost(common_1.Utils.readStream(path), { headers })
                    .then(({ body }) => ({ id: body.id }));
            }));
        });
    }
}
exports.AttachmentsService = AttachmentsService;
