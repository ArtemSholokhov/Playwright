"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AutotestsService = void 0;
const testit_api_client_1 = require("testit-api-client");
const base_service_1 = require("../base.service");
const autotests_converter_1 = require("./autotests.converter");
const autotests_handler_1 = require("./autotests.handler");
const autotestApiKey = testit_api_client_1.AutoTestsApiApiKeys["Bearer or PrivateToken"];
class AutotestsService extends base_service_1.BaseService {
    constructor(config) {
        super(config);
        this.config = config;
        this._client = new testit_api_client_1.AutoTestsApi(config.url);
        this._client.setApiKey(autotestApiKey, `PrivateToken ${config.privateToken}`);
        this._converter = new autotests_converter_1.AutotestConverter(config);
    }
    createAutotest(autotest) {
        return __awaiter(this, void 0, void 0, function* () {
            const autotestPost = this._converter.toOriginAutotest(autotest);
            return yield this._client
                .createAutoTest(autotestPost)
                .then(() => console.log(`Create autotest "${autotest.name}".`))
                .catch((err) => (0, autotests_handler_1.handleHttpError)(err, `Failed create autotest "${autotestPost.name}"`));
        });
    }
    updateAutotest(autotest) {
        return __awaiter(this, void 0, void 0, function* () {
            const autotestPost = this._converter.toOriginAutotest(autotest);
            yield this._client
                .updateAutoTest(autotestPost)
                .then(() => console.log(`Update autotest "${autotest.name}".`))
                .catch((err) => (0, autotests_handler_1.handleHttpError)(err, `Failed update autotest "${autotestPost.name}"`));
        });
    }
    loadPassedAutotest(autotest) {
        return __awaiter(this, void 0, void 0, function* () {
            const originAutotest = yield this.getAutotestByExternalId(autotest.externalId);
            !originAutotest ? yield this.createAutotest(autotest) : yield this.updateAutotest(autotest);
        });
    }
    loadFailedAutotest(autotest) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b;
            const originAutotest = yield this.getAutotestByExternalId(autotest.externalId);
            !originAutotest
                ? yield this.createAutotest(autotest)
                : yield this.updateAutotest(Object.assign(Object.assign({}, originAutotest), { externalId: (_a = originAutotest === null || originAutotest === void 0 ? void 0 : originAutotest.externalId) !== null && _a !== void 0 ? _a : autotest.externalId, name: (_b = originAutotest === null || originAutotest === void 0 ? void 0 : originAutotest.name) !== null && _b !== void 0 ? _b : autotest.name, links: autotest.links }));
        });
    }
    loadAutotest(autotest, isPassed) {
        return __awaiter(this, void 0, void 0, function* () {
            isPassed ? yield this.loadPassedAutotest(autotest) : yield this.loadFailedAutotest(autotest);
        });
    }
    linkToWorkItems(externalId, workItemIds) {
        return __awaiter(this, void 0, void 0, function* () {
            const internalId = yield this.getAutotestByExternalId(externalId).then((test) => test === null || test === void 0 ? void 0 : test.id);
            if (internalId === undefined) {
                throw new Error(`Autotest with external id ${externalId} not found`);
            }
            const promises = workItemIds.map((workItemId) => this._client.linkAutoTestToWorkItem(internalId, { id: workItemId }));
            yield Promise.all(promises).catch((err) => (0, autotests_handler_1.handleHttpError)(err, "Failed link work item"));
        });
    }
    getAutotestByExternalId(externalId) {
        return __awaiter(this, void 0, void 0, function* () {
            const filterModel = {
                externalIds: [externalId],
                projectIds: [this.config.projectId],
                isDeleted: false,
            };
            const includesModel = {
                includeSteps: false,
                includeLinks: false,
                includeLabels: false
            };
            const requestModel = {
                filter: filterModel,
                includes: includesModel
            };
            return yield this._client.apiV2AutoTestsSearchPost(undefined, undefined, undefined, undefined, undefined, requestModel)
                .then(({ body }) => body[0])
                .then((autotest) => {
                return autotest ? this._converter.toLocalAutotest(autotest) : null;
            });
        });
    }
}
exports.AutotestsService = AutotestsService;
