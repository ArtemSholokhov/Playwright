"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.testit = void 0;
const crypto_1 = require("crypto");
const test_1 = __importDefault(require("@playwright/test"));
var ContentType;
(function (ContentType) {
    ContentType["TEXT"] = "text/plain";
    ContentType["XML"] = "application/xml";
    ContentType["HTML"] = "text/html";
    ContentType["CSV"] = "text/csv";
    ContentType["TSV"] = "text/tab-separated-values";
    ContentType["CSS"] = "text/css";
    ContentType["URI"] = "text/uri-list";
    ContentType["SVG"] = "image/svg+xml";
    ContentType["PNG"] = "image/png";
    ContentType["JSON"] = "application/json";
    ContentType["ZIP"] = "application/zip";
    ContentType["WEBM"] = "video/webm";
    ContentType["JPEG"] = "image/jpeg";
    ContentType["MP4"] = "video/mp4";
})(ContentType || (ContentType = {}));
class testit {
    static async addMetadataAttachment(metadata) {
        await test_1.default.info().attach("tms-metadata.json", {
            contentType: "application/vnd.tms.metadata+json",
            body: Buffer.from(JSON.stringify(metadata), "utf8"),
        });
    }
    static async addAttachment(name, content, options) {
        const stepName = `stepattach_${(0, crypto_1.randomUUID)()}_${name}`;
        const contentType = typeof options === "string" ? options : options.contentType;
        await this.step(stepName, async () => {
            await test_1.default.info().attach(stepName, {
                body: content,
                contentType,
            });
        });
    }
    static async mapParams(params) {
        switch (typeof params) {
            case 'string':
            case 'bigint':
            case 'number':
            case 'boolean':
                return { value: params.toString() };
            case 'object':
                if (params === null) {
                    return {};
                }
                return Object.keys(params).reduce((acc, key) => {
                    acc[key] = params[key].toString();
                    return acc;
                }, {});
            default:
                return {};
        }
    }
    static async workItemIds(value) {
        await this.addMetadataAttachment({
            workItemIds: value,
        });
    }
    static async displayName(value) {
        await this.addMetadataAttachment({
            displayName: value,
        });
    }
    static async externalId(value) {
        await this.addMetadataAttachment({
            externalId: value,
        });
    }
    static async title(value) {
        await this.addMetadataAttachment({
            title: value,
        });
    }
    static async description(value) {
        await this.addMetadataAttachment({
            description: value,
        });
    }
    static async labels(value) {
        await this.addMetadataAttachment({
            labels: value.map((label) => ({ name: label })),
        });
    }
    static async links(value) {
        await this.addMetadataAttachment({
            links: value,
        });
    }
    static async namespace(value) {
        await this.addMetadataAttachment({
            namespace: value,
        });
    }
    static async classname(value) {
        await this.addMetadataAttachment({
            classname: value,
        });
    }
    static async addLinks(value) {
        await this.addMetadataAttachment({
            addLinks: value,
        });
    }
    static async addMessage(value) {
        await this.addMetadataAttachment({
            addMessage: value,
        });
    }
    static async params(value) {
        await this.addMetadataAttachment({
            params: await this.mapParams(value),
        });
    }
    static step(name, body) {
        return test_1.default.step(name, body);
    }
}
exports.testit = testit;
