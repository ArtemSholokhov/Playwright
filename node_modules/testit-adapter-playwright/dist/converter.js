"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.stripAscii = exports.Converter = void 0;
var Status;
(function (Status) {
    Status["PASSED"] = "Passed";
    Status["FAILED"] = "Failed";
    Status["SKIPPED"] = "Skipped";
})(Status || (Status = {}));
class Converter {
    static convertTestCaseToAutotestPost(autotestData) {
        return {
            externalId: autotestData.externalId,
            name: autotestData.displayName,
            title: autotestData.title,
            description: autotestData.description,
            labels: autotestData.labels,
            links: autotestData.links,
            namespace: autotestData.namespace,
            classname: autotestData.classname,
            workItemIds: autotestData.workItemIds,
        };
    }
    static convertAutotestPostToAutotestResult(autotestData, test, result) {
        const autotestResult = {
            autoTestExternalId: autotestData.externalId,
            outcome: this.convertStatus(result.status, test.expectedStatus),
            links: autotestData.addLinks,
            duration: result.duration,
            parameters: autotestData.params,
            attachments: autotestData.addAttachments,
            message: autotestData.addMessage,
        };
        if (result.error) {
            const status = getStatusDetails(result.error);
            autotestResult.message = status.message;
            autotestResult.traces = status.trace;
        }
        return autotestResult;
    }
    static convertTestStepsToShortSteps(steps) {
        return steps.map(step => {
            return this.convertTestStepToShortStep(step);
        });
    }
    static convertTestStepToShortStep(step) {
        return {
            title: step.title,
        };
    }
    static convertTestStepsToSteps(steps, attachmentsMap) {
        return steps.map(step => this.convertTestStepToStep(step, attachmentsMap));
    }
    static convertTestStepToStep(step, attachmentsMap) {
        return {
            title: step.title,
            outcome: step.error ? Status.FAILED : Status.PASSED,
            attachments: [...attachmentsMap.keys()].filter((attachmentId) => attachmentsMap.get(attachmentId) === step),
        };
    }
    static convertStatus(status, expectedStatus) {
        if (status === "skipped") {
            return Status.SKIPPED;
        }
        if (status === expectedStatus) {
            return Status.PASSED;
        }
        return Status.FAILED;
    }
    ;
}
exports.Converter = Converter;
const getStatusDetails = (error) => {
    const message = error.message && (0, exports.stripAscii)(error.message);
    let trace = error.stack && (0, exports.stripAscii)(error.stack);
    if (trace && message && trace.startsWith(`Error: ${message}`)) {
        trace = trace.substr(message.length + "Error: ".length);
    }
    return {
        message: message,
        trace: trace,
    };
};
const stripAscii = (str) => {
    return str.replace(asciiRegex, "");
};
exports.stripAscii = stripAscii;
const asciiRegex = new RegExp("[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:[a-zA-Z\\d]*(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)|(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))", "g");
