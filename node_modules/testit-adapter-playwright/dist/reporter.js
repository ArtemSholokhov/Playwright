"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
const testit_js_commons_1 = require("testit-js-commons");
const converter_1 = require("./converter");
const stepAttachRegexp = /^stepattach_(\w{8}-\w{4}-\w{4}-\w{4}-\w{12})_/i;
class TmsReporter {
    constructor(options) {
        this.testCache = new Array();
        this.stepCache = new Map();
        this.attachmentSteps = new Map();
        this.globalStartTime = new Date();
        this.loadTestPromises = new Array();
        this.options = { suiteTitle: true, detail: true, ...options };
        const config = new testit_js_commons_1.ConfigComposer().compose();
        const client = new testit_js_commons_1.Client(config);
        this.strategy = testit_js_commons_1.StrategyFactory.create(client, config);
        this.additions = new testit_js_commons_1.Additions(client);
    }
    onBegin(config, suite) {
        this.config = config;
        this.suite = suite;
    }
    onTestBegin(test) {
        this.testCache.push(test);
    }
    onTestEnd(test, result) {
        this.loadTestPromises.push(this.loadTest(test, result));
    }
    onStepBegin(test, _result, step) {
        if (!this.testCache.includes(test)) {
            return;
        }
        if (step.category !== "test.step") {
            return;
        }
        if (this.stepCache.get(step)) {
            return;
        }
        this.stepCache.set(step, test);
    }
    async onEnd() {
        await Promise.all(this.loadTestPromises);
        this.addSkippedResults();
    }
    addSkippedResults() {
        const unprocessedCases = this.suite
            .allTests()
            .filter((testCase) => !this.testCache.includes(testCase));
        unprocessedCases.forEach((testCase) => {
            this.onTestEnd(testCase, {
                status: "skipped",
                attachments: [],
                duration: 0,
                errors: [],
                parallelIndex: 0,
                workerIndex: 0,
                retry: 0,
                steps: [],
                stderr: [],
                stdout: [],
                startTime: this.globalStartTime,
            });
        });
    }
    printsToStdio() {
        return false;
    }
    async getAutotestData(test, result) {
        const autotestData = {
            externalId: testit_js_commons_1.Utils.getHash(test.title),
            displayName: test.title,
            addAttachments: []
        };
        for (const attachment of result.attachments) {
            if (!attachment.body) {
                continue;
            }
            if (attachment.contentType === "application/vnd.tms.metadata+json") {
                const metadata = JSON.parse(attachment.body.toString());
                if (metadata.externalId) {
                    autotestData.externalId = metadata.externalId;
                }
                if (metadata.displayName) {
                    autotestData.displayName = metadata.displayName;
                }
                if (metadata.title) {
                    autotestData.title = metadata.title;
                }
                if (metadata.description) {
                    autotestData.description = metadata.description;
                }
                if (metadata.labels) {
                    autotestData.labels = metadata.labels;
                }
                if (metadata.links) {
                    autotestData.links = metadata.links;
                }
                if (metadata.namespace) {
                    autotestData.namespace = metadata.namespace;
                }
                if (metadata.classname) {
                    autotestData.classname = metadata.classname;
                }
                if (metadata.addLinks) {
                    autotestData.addLinks = metadata.addLinks;
                }
                if (metadata.addMessage) {
                    autotestData.classname = metadata.addMessage;
                }
                if (metadata.params) {
                    autotestData.params = metadata.params;
                }
                if (metadata.workItemIds) {
                    autotestData.workItemIds = metadata.workItemIds;
                }
                continue;
            }
            if (attachment.name.match(stepAttachRegexp)) {
                const step = [...this.stepCache.keys()].find((step) => step.title === attachment.name);
                if (step) {
                    this.stepCache.delete(step);
                }
                await this.additions.addAttachments(attachment.body.toString(), attachment.name.replace(stepAttachRegexp, "")).then((ids) => {
                    if (step?.parent) {
                        this.attachmentSteps.set(ids[0], step.parent);
                        return;
                    }
                    autotestData.addAttachments?.push(...ids);
                });
            }
        }
        return autotestData;
    }
    async loadTest(test, result) {
        const autotest = converter_1.Converter.convertTestCaseToAutotestPost(await this.getAutotestData(test, result));
        const steps = [...this.stepCache.keys()].filter((step) => this.stepCache.get(step) === test);
        autotest.steps = converter_1.Converter.convertTestStepsToShortSteps(steps);
        await this.strategy.loadAutotest(autotest, converter_1.Converter.convertStatus(result.status, test.expectedStatus) == "Passed");
        const autotestResult = converter_1.Converter.convertAutotestPostToAutotestResult(await this.getAutotestData(test, result), test, result);
        autotestResult.stepResults = converter_1.Converter.convertTestStepsToSteps(steps, this.attachmentSteps);
        await this.strategy.loadTestRun([autotestResult]);
    }
}
exports.default = TmsReporter;
__exportStar(require("./labels"), exports);
